시간복잡도 Big-O
추상화해서 생각 -> 환경적 요인 고려 x -> 추상적인 알고리즘 본체에 대한 수행시간의 개념 -> 시간복잡도
- f(n) <= O(g(n)) -> worst
	- 함수f의 증가속도가 g보다 빠르지 않다(즉 비슷하거나 느리다) 
- f(n) >= Ω(g(n)) -> best
	- 함수f의 증가속도가 g보다 느리지 않다(즉 비슷하거나 빠르다) 
- f(n) = Θ(g(n)) 
	- 함수f의 증가속도가 g와 비슷하다
![[Pasted image 20250314095221.png]]
$$
1 < log(log n) < log n < (log n)^2 < n^{1/2} < n < n log n < n^2 < n^3 < 2^n < n! < n^n
$$


선택정렬
```c
void selection_sort(int A[], int n){
	for(int i=0; i<n-1; i++){ //3
		int indexMin = i;
		for(int j=i+1; j<n; j++){ //(n-i-1)*6 + 1
			if(A[j] < A[indexMin]) indexMin= j;
		}
		int temp = A[indexMin];
		A[indexMin] = A[i];
		A[i] = temp; //6
	}
} //worst case: 3 + (n-i+1)*6 + 1 + 6 = 시그마(i=0부터 n-2까지)6(n-i) + 16 = 16(n-1) + 3n(n+1) -6
```
-> BIG-O 표기 -> O(n^2)

삽입정렬
```c
void insertion_sort(int A[], int n){
	for(int i=1; i<n; i++){
		int key = A[i];
		for(int j=i-1; j>=0 && A[j] > key; j--){
			A[j+1] = A[j]; 
			A[j] = key;
		}
	}
}
```
-> 역순일 때 최악의 경우
-> 정렬된 만큼 빠르게 수행 됨

버블정렬
```c
void bubble_sort(int A[], int n){ 
	for(int i=0; i<n; i++){
		for(int j=0; j<n-1; j++){
			if(A[j]>A[j+1]) { 
				int temp = A[j]; 
				A[j+1] = A[j]; 
				A[j] = temp; 
			} 
		}
	}
}
```
Mergesort
1. 주어진 배열을 (대략 절반으로)둘로 나눈다 
2. 두 subarray를 각각 “정렬”한다(by recursion) 
3. 정렬된 두subarray를 합쳐서(merge) 하나의 정렬된 배열로 만든다
![[Pasted image 20250321105901.png]]
MERGE의 시간복잡도: O(n) -> 재귀에 의해 내부의 MERGESORT도 O(n) -> 따라서 MERGESORT의 시간복잡도는 3 * O(n) = O(n)
*[]: floor 반내림*
T(n) = MergeSort(A[1..n])의 시간복잡도
T(n)의 점화식: T(n) = T([n/2]) + T([n/2]) + O(n) = 2T([n/2]) + O(n)
따라서 점화식을 풀면 T(n) = O(nlogn)

Quicksort
1. 주어진 배열의 원소 중에(아무거나) pivot을 고른다 
2. (Partition) pivot을 기준으로 작은 것들과 큰 것들을 분류하여 이동시킨다 즉,pivot 보다 작은건 앞으로 큰건 뒤로 하여 pivot을 중심으로 두개의 subarray가 만들어짐 
3. 이 두 subarray를 각각 “정렬”한다(by recursion)
![[Pasted image 20250321112426.png]]

![[Pasted image 20250321112443.png]]
T(n) = T(r-1) + T(n-r) + O(n) => 평균적으로 O(nlogn)
최악의 경우(최솟값이 매번 피봇으로 선택되는 경우)
- r=1 or r=n
- T(n-1) + O(n) = O(n^2)

QuickSelect
```
QuickSelect(A[1..n], k):
	if n = 1
		return A[1]
	else
		Choose a pivot element A[p]
		r = Partition(A[1..n], p)
		if k < r
			return QuickSelect(A[1..r-1], k)
		else if k > r
			return QuickSelect(A[r + 1..n], k - r)
		else
			return A[r]
```
-> T(n) <= max{T(r-1), T(n-r)} + O(n)
최악의 경우 O(n^2)
최선의 경우: 피벗이 대략 중간값 일 때 -> O(n)
Good Pivot
Median-of-Medians Selection
- 배열A[1..n]의원소n개를5개씩묶어n/5개의block으로나눈다 
- 각block의median을계산한다(5개중3번째)
- 위에서계산한median들을모아서배열M[1..n/5]에모은후 이들의median을찾아서그걸pivot으로사용한다

-> MOM은 보다 큰 요소와 작은 요소가 3n/10개씩 있다
-> 최대 7n/10을 가짐
T(n) <= T(n/5) + T(7n/10) + O(n)
-> 점점 작아지는 tree를 가짐(n -> 9n/10 -> 81n/100 -> ...) 
-> 공비가 9/10 -> 10n -> O(n)


Reduction
X를 풀기 위한 알고리즘을 기술 할 때 Y의 알고리즘을 호출
- 활용하는 Y의 알고리즘이 어떻게 동작하는지는 신경 쓰지 않는다
- 단, 그 알고리즘이 문제Y를 정확하게 해결한다는 것만 가정한다
- Y의 알고리즘을 이해하지 않고 단순히 '활용'하는 것
- Y를 이해하고 있어도 모르는 척하고 쓰는 것이 더 유용하다
- Examples 
	- 배열A[0..n-1]에서 최솟값 찾기 
		1. A를 정렬한다 
		2. return A[0] 
	- Selection(A[0..n-1], k) // 배열 A에서 k번째로 작은 값 찾기 
		1. A를 정렬한다 
		2. return A[k-1]
- Selection문제를 정렬 문제로 reduce하여 해결함 
	- Selection is reduced to Sorting 
	- Selection을 풀기 위해 Sorting 알고리즘을 subroutine으로 활용

Recursion은 결국 같은 문제로 Reduction 하는 것
- 단, 입력 사이즈가 줄어들어야 함
팩토리얼
```c
int fact(int n) {
	if(n==0) 
		return 0; 
	else 
		return n*fact(n-1); //재귀, Reduction
}
```

![[Pasted image 20250321103432.png]]
>이진 트리 형태로 재귀 함수 호출
수학적 귀납법 -> n일 때 명제가 참인 것을 증명하기 위해서 n-1일 때가 참이라고 가정한다 -> n이 계속 줄어들면서 참임을 증명
base case -> if n> 0  -> n이 0인 경우
simplify: 작은 instance를 만든다
delegate: 위임하고 잊는다

Multiplication(곱하기)

Matrix Multiplication(행렬 곱)

Binary Search(이진 탐색)

#### 시간복잡도 분석
하노이 타워: Move를 몇 번 수행하는가
T(n): disc가 n개일 때 실행되는 Move의 횟수
T(0)=0, T(1)=1, T(2)=3, T(3)=7, ...
T(n) = T(n-1)재귀 + T(n-1)재귀 + 1(move)
T(n-1) = T(n-2) + T(n-2) + 1
... -> 점화식 T^n - 1
![[Pasted image 20250321105603.png]]

DIvide and Conquer

점화식/시간복잡도
T(n) = rT(n/c) +O(f(n))
r: 재귀 횟수
트리 깊이(L): $log_c n$, 노드 수: $r^L = r^{log_c n} = n^{log_c r}$

T(n) = 2T(n/2) + O(n)
T(n) = T(n/2) + O(n)
T(n) = T(n/2) + O(1)
T(n) = 4T(n/2) + O(n)
T(n) = 3T(n/2) + O(n)
T(n) = T(n/3) + O($n^2$)
T(n) = 2T(n/2) + O(nlogn)
T(n) = T(n/3) + T(2n/3) + O(n)
-> 두 개의 분기로 나뉨 (n/3, 2n/3) -> 계속해서 각각 똑같은 비율로 나뉨 -> 따라서 각 층 마다 합을 구하면 = n -> 최종적으로 O(nlogn)
![[Pasted image 20250404092548.png]]
(2/3)^n = 1 -> 깊이 log_3/2 n
T(n) = T(n - 2) + T(2) + O(n)
A(n) = 2A(n/4) + $\sqrt{n}$ -> case2 -> O($\sqrt{n}logn$)

B(n) = 2B(n/4) +n -> case1 -> O(n)

C(n) = 2C(n/4) + $n^2$ -> case1 -> O($n^2$)

D(n) = 3D(n/3) + $\sqrt{n}$ -> case3 -> O(n)

E(n) = 3E(n/3) +n -> case2 -> O(nlogn)

F(n) =3F(n/3) + $n^2$ -> case1 -> O($n^2$)

G(n) =4G(n/2) + $\sqrt{n}$ -> case3 -> O($n^2$)

H(n) =4H(n/2) +n -> case3 -> O($n^2$)

I(n) =4I(n/2) + $n^2$ -> case2 -> O($n^2logn$)

J(n) = J(n/2) + J(n/3) + J(n/6) + n
![[Pasted image 20250412140152.png]]
깊이:  log n, 문제 크기 n -> O(nlogn)

K(n) = K(n/2) + 2K(n/3) + 3K(n/4) + $n^2$
문제 크기 $n^2$ -> $cn^2$ -> ... -> $n^2$ 비례 -> O($n^2$)

L(n) = L(n/15) + L(n/10) + 2L(n/6) + $\sqrt{n}$
$\sqrt{n}$ -> $c\sqrt{n}$ -> ... -> $\sqrt{n}$에 비례 -> O($\sqrt{n}$)

N Queens

Subset Sum
- T=0 -> 항상 True, T < 0 -> 항상 False
- x in X
- 총 합이 T인 X의 부분집합이 존재한다면
	- x를 포함
		- 총합이 T-x인 X-x의 부분집합이 존재
	- x를 포함 안 함
		- 총합이 T인 X-x의 부분집합이 존재
-> 두 개의 경우로 reduce하고 recursion가능
```
SubsetSum(X, i, T):
	if T=0
		return True
	else if T<- or i=0
		return False
	else
		with <- SubsetSum(X, i-1, T-X[i])
		wout <- SubsetSum(X, i-1, T)
		return (with or wout)
```
A(n) <= 2A(n-1) + O(1)  -> O(2^n)


과제1
