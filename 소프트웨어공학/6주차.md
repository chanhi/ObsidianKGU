설계와 구현

설계와 구현은 필연적으로 ==상호 중첩==
- 설계: 발주자의 요구사항을 기반으로 SW컴포넌트와 그들 간의 관계를 식별하는 ==창조적인 활동==이다. 
- 구현: 설계를 프로그램으로 ==실현하는 과정==이다.

Cummersially of the Shelf(COTS)

객체 지향 설계 프로세스
대규모 시스템에 적합

공통 활동들
- 문맥과 시스템의 사용 모드를 정의한다
- 시스템 아키텍처를 설계한다
- 주요 시스템 객체를 식별한다
- 설계 모델을 개발한다
- 객체 인터페이스를 명세한다

 시스템 문맥과 상호작용
- 설계될 소프트웨어와 ==외부 환경과의 관계==를 이해하는 것이 요구된 시스템 기능을 제공하는 방법과 환경과 통신하도록 시스템의 구성 방법을 결정하는데 필수적이다.
- 문맥 이해는 또한 ==시스템 경계를 설정==하게 한다. 시스템 경계를 설정하는 것은 설계되는 시스템에 무슨 피쳐들을 구현할 것 인지와 다른 연관된 시스템에 어떤 피쳐들이 있을 지를 결정하는 것을 돕는다

문맥과 상호작용 모델
- 문맥 모델은 정적 모델
- 상호작용 모델은 동적 모델

아키텍처 설계
- 시스템을 구성하는 주요 ==컴포넌트들과 그들의 상호작용을 식별==한다. 그리고 계층형 또는 클라이언트-서버 모델과 같은 아키텍처 패턴을 사용하여 컴포넌트들을 조직화한다
- 기상 관측소는 공통의 인프라 구조상에서 메시지를 방송함으로서 통신하는 독립 서브 시스템들로 구성된다

객체 클래스 식별
- 객체 클래스들을 식별하는 것은 보통 객체-지향 설계의 어려운 부분이다.
- 객체 식별을 위한‘마법공식’은 없다. 시스템 설계자의 기술, 경험, 그리고 ==도메인지식(현장 지식)==에 의존한다.
- 객체 식별은 반복적인 프로세스이다

자연어의 문법적인 접근을 사용 -> 예)CRC 객체지향 설계
명백한 것의 식별을 기반
행위적인 방법으로 식별
시나라오 기반 분석을 사용

설계 모델
- 객체들, 객체 클래스들, 클래스들 간의 관계를 나타낸다
	- 구조 모델은 객체 클래스들과 관계에 의해서 시스템의 정적구조를 나타냄
	- 동적 모델은 객체들 간의 동적 상호작용을 나타냄

설계 패턴

패턴: 최고관행, 좋은 설계를 기술하는 방법, 경험을 포착해서 이러한 경험 다른데에 재사용 가능하도록 하는 방식

옵저버 패턴: 객체 스스로를 객체의 상태를 분리?

gof의 23개의 설계 패턴

재사용 비용
- 시간 비용
- 구매 비용
- 적용 및 설정 비용
- 통합 비용

형상관리
형상관리의 목적은 시스템 통합 프로세스를 지원하는 것. 모든 개발자들이 ==통제된== 방식으로 프로젝트 코드와 문서에 접근

버전관리
시스템 통합
문제 추적

호스트-타겟 개발

통합 컴파일러와 구문-지향적인 편집기
디버거
그래픽 편집 도구
테스팅 도구
프로젝트 지원 도구

배치 요인
- 고가용성 시스템들은 컴포넌트들을 하나 이상의 플랫폼에 배치할 것을 요구
- 만약 컴포넌트간의 높은 수준의 통신 트래픽이 있다면, 똑같은 플랫폼에 배치하거나 물리적으로 가까운 플랫폼에 배치하는 것이 현명

시큐어 코딩 가이드라인 
misra-c 코딩 가이드 -> 자동차 모델 기반의 코딩 규칙

오픈 소스 개발
- 원조는 FSF (Free Software Foundation, www.fsf.org) 이고, 소스 코드는 소유권 이라기 보다는 사용자들이 원할 때 조사하고 수정하도록 항상 공개되어야 한다고 주장
- 오픈소스 개발은 소프트웨어 개발 방법 중의 하나로서, 소프트웨어시스템의 소스 코드를 올려놓고 그 개발 과정에 참여하도록 자원자를 초대하는 개발 방법

라이선스 모델
- GNU GPL(General Public License) 라이선스: 라이선스 하에 있는 오픈소스를 이용한다면, 해당 소프트웨어를 오픈소스로 해야 하는, 상호 라이선스이다. 
- LGPL 라이선스: 오픈소스와 연결된 컴포넌트를 작성할 수 있으나, 이들컴포넌트의 소스를 공개하지 않아도 된다. 
- BSD 라이선스: 비 상호 라이선스, 오픈소스에 가해진 변경이나 수정을 재공개할 의무가 없다. 오픈 소스코드를 판매하는 사유 시스템에 포함할 수 있다.

unit 07
SOLID 설계 원칙
단일 책임 원칙
- 각 클래스는 하나의 기능을 수행
- 한 클래스가 많은 기능을 수행하면 코드가 복잡해 진다
개방 폐쇄 원칙
- 새로운 변경이 발생되었을 때, 확장은 쉽되 수정은 최소화
리스코프 치환 원칙
- 상위 클래스를 하위 클래스로 완전히 대치할 수 있어야 한다
인터페이스 분리 원칙
- 큰 규모의 인터페이스는 여러 개로 분할
의존성 역전 원칙
- 구체적인 구현 대신 추상화를 사용