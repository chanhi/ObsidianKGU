ch1

4
OS는 하드웨어를 관리하는 소프트웨이며 프로그램을 수행하는 환경을 제공한다
자원 할당자이자 프로그램 컨트롤러

5
컴퓨터가 시작/재부팅 되면 부트스트랩 프로그램이 로드
커널을 로드하고 실행을 시작
이벤트 발생은 SW/HW의 인터럽트로 신호가 전달된다.

6
다른 인터럽트가 처리되는 동안 들어오는 인터럽트는 비활성화 된다
트랩: 오류나 사용자의 요청에 의해 발생하는 SW인터럽트

7
app -> (시스템 콜 ex. api) <-> os <-> hw
모든 운영체제는 시스템 콜을 표준 라이브러리로 제공
fd = open("a.txt", "w"); //open 이라는 라이브러리 함수가 시스템 콜을 수행

![[Pasted image 20250312092337.png]]

fork(); -> libc.c 안에 fork함수 -> 해당 함수 안에 어셈블리(시스템 콜 수행) -> 시스템 콜 테이블 -> 해당 테이블에 있는 커널 함수 수행 -> hw 수행

![[Pasted image 20250312094236.png]]
INT(인터럽트) 벡터 테이블 ISR(인터럽트 서비스 루틴)

9
메모리에 프로그램 로드
fetch
decoding
operrand
execute
store

10
저장장치 계층도
![[Pasted image 20250312094031.png]]
휘발성/비휘발성

11
입출력 구조
IO 장치와 CPU 장치는 동시에 수행할 수 있다.

12
인터럽트 방식 -> bulk(대량의) 데이터를 보낼 때 비효율적 -> 수행할 때 마다 인터럽트가 발생하기 때문(CPU가 계속 작업을 한다) -> 지불해야 할 비용이 크다
DMA(Direct Memory Access) 방식 -> CPU 개입 없이 대량의 데이터를 메모리에 전송할 수 있다. -> IO장치와 메모리 장치 사이에서 대량의 데이터를 전송하는 사이에 CPU가 개입하면 데이터가 깨진다.

14
![[Pasted image 20250312093813.png]]
인터럽트, DMA 방식으로 데이터를 송수신 하는 버스가 있다

16
Sysmmetric Multiprocessing Architecture
cpu를 병렬로 연결한 단순한 구조 -> 병목 현상이 생길 우려 있음

17
듀얼 코어 디자인
공유캐시, 개별 캐시

18
NUMA
cpu 마다 메모리 하나 -> 복잡해짐 -> 메모리를 공유하지 않으므로 프로세스를 잘 설계할 필요가 있다.

19
단일 프로그래밍 -> 사용자 한 명이 사용하므로 IO 장치와 cpu를 동시에 바쁘게 할 수 없다 -> 효율성 떨어짐
cpu  p1    x       
IO            p1

멀티 프로그래밍 -> 메모리에 여러 프로세스를 올린다 ->  서로 다른 프로세스가 CPU를 번갈아 가면서 빈 시간을 공유하여 작업하도록 한다.
cpu     p1      p2       p3  ...
IO                 p1       p2  ...   -> 얘들은 그냥 명령 받은 순서대로 수행

타임쉐어링(멀티태스킹)(시분할): 멀티프로그래밍의 논리적 확장
p1 p2 p3 p1 p2 p3 p1 p3 ... 계속해서 짧게 할당된 시간만큼만 프로세스에 CPU를 사용한다. -> 할당된 시간 안에 수행하지 못하면 다음 프로세스에게 할당 -> 완료 될 때까지 반복

20
어떤 프로세스를 먼저 수행 할 것인가 -> CPU 스케쥴링
어떤 프로세스를 먼저 CPU에 올릴 것인가 -> job 스케쥴링
메모리가 부족하면 가상메모리를 사용하거나 swapping(하드가 대신 잠시 올려두는 느낌) 발생

21
SW interrupts - trap(or exception)
소프트웨어 에러, 시스템 콜, 프로세스 문제 등이 있을 때 발생
타이머: 무한 루프나 자원독점을 방지하기 위해 사용됨
듀얼 모드 execution: cpu가 사용하는 여러 모드를 어떤 상황이 되면 모드에 따라 수행되도록 할 수 있다.
user mode 유저만 사용, kernel mode 커널만 사용
ex) 
타이머 설정 -> 커널
시간 읽기 -> 유저

![[Pasted image 20250312104451.png]]
mode bit 모드를 결정하는 bit -> 하드웨어에서 결정되어 있음
모든 cpu가 dual mode를 지원하는 것은 아님 -> 어떤 모드가 어떤 수행을 하는지는 하드웨어에 미리 디자인 되어있다.

27
프로세스 관리
프로세스: 프로그램을 구성하는 기본적인 단위
쓰레드:

28
프로세스간 해야 할 일 synchronization

29
메모리 관리

30 
storage 관리 -> 파일 시스템, 캐싱, I/O 시스템

32
OS가 무엇인가
OS 동작
==멀티프로그래밍, 타임쉐어링의 특징과 차이점점

### ch2

![[Pasted image 20250312111853.png]]
6
시스템 콜
각각 번호가 매겨져 있는 커널 명령을 수행하기 위한 인터페이스

APIs -> 시스템 콜 라이브러리
user mode               kernel mode
open(api)     ->        시스템 콜 
![[Pasted image 20250312112637.png]]
10
시스템 콜 파라미터 전달

11
ex)
![[Pasted image 20250312092337.png]]
fork함수가 실행됨 -> 라이브러리로 선언되어 있는 시스템 콜을 fork 함수 내부에서 수행 -> 위 그림처럼 시스템 호출 번호 2를 레지스터에 넣고 인터럽트를 발생시켜 시스템 콜을 수행 -> 인터럽트 디스크럽터 테이블(IDT)에서 레지스터 값을 참고로 시스템 콜 테이블에서 함수를 호출 -> 실제 기능 수행행
![[Pasted image 20250312113801.png]]
유저 모드에서 getpid()를 호출 -> C-lib에서 인터럽트를 발생시키면서 시스템 콜 호출 -> 커널 모드로 바뀌면서 시스템 콜 테이블에서 해당 함수 호출 -> 수행 -> 다시 유저모드로 변경

12
사용자 지정 시스템 콜 만들기
-> 시스템 콜 함수 정의 -> 시스템 콜 번호 할당 -> 함수 등록 -> rebuild

17
시스템 콜의 형태(이미 있는 거)